In this project you'll build an e-commerce site for a small grocery that wants to sell products directly to customers over the web.  The project will be built in discreet iterations:

* I0: Up and Running
* I1: Basic Product Listings
* I2: Handling Stock
* I3: Designing Orders
* I4: Improving the Orders Interface
* I5: Dealing with Order Quantities
* I6: Establishing Identity  
* I7: Checkout

Each of these iterations will start and end with a working product.

h2. I0: Up and Running

Part of the reason Ruby on Rails became popular quickly is that it takes a lot of the hard work off your hands, and that's especially true in starting up a project.  Rails practices the idea of "sensible defaults" and tries to, with one command, create you a working application ready for your customization.

h3. Setting the Stage

First we need to make sure everything is setup and installed.  See the "Preparation for Rails Projects":/resources/rails-jumpstart/preparation/ page for instructions on setting up and verifying your Ruby, Rails, and add-ons.

h4. Generate the Project

Let's lay the groundwork for our project.  In your terminal, switch to the directory where you'd like your project to be stored.  I'll use @~/Projects@.

Run the @rails -v@ command and you should see your current Rails version, mine is *3.0.7*.  Let's create a new Rails project:

<pre class='console'>
  rails new JSMerchant
</pre>

Then @cd@ into your project directory and open the project in your editor of choice, I'll use RubyMine.  

h4. Booting the Server

From your project directory we need to run the bundler system to setup our dependency libraries.  At the command prompt enter:

<pre class='console'>
  bundle
</pre>

Once that completes your app is ready to go. Start it up with this instruction:

<pre class='console'>
  rails server
</pre>

Then try loading the address "http://localhost:3000/":http://localhost:3000.  You should see Rails' "Welcome Aboard" page.  Click the "About your application's environment" link and it'll display the versions of all your installed components.

h3. Using Scaffolds

Rails makes it really easy to begin modeling your data using scaffolding.  The built in scaffolds are fine, but I prefer to use the @nifty-generators@ created by "RailsCasts author Ryan Bates":http://railscasts.com.

In the development section of your @Gemfile@, add a dependency for @"nifty-generators"@, run @bundle@ from the command prompt again to install the library.  

h4. Nifty Layout

After it finishes, run this generator, answering @yes@ to the conflict:

<pre class="console">
  rails generate nifty:layout
</pre>

That sets us up to use his "nifty" scaffolding. In the course of generating our the layout scaffold, the NiftyGenerators package inserted a new dependency in the @Gemfile@.  Run @bundle@ again to set it up. 

h4. Nifty Scaffold 

We'll start by thinking about a "product" in our store.  What attributes does a product have?  What type of data are each of those attributes?  We don't need to think of EVERYTHING up front, here's a list to get us started:

* @title@ which should be a @String@
* @price@ which should be an @Integer@
* @description@ which should be @text@
* @image_url@ which should be a @String@

Why make @price@ an @Integer@?  This is a bit of a computer science trick.  Dealing with floating point numbers, those with decimal fractions, can often be a big pain in the neck.  Although we normally think of prices with a decimal point (like $10.45) they aren't real floats because the number of places at the decimal doesn't change -- it's always two.  When programming, it's usually better to represent money in cents as an integer, then when you have to actually print it out just insert the ".".  Trust me for right now.

Ok, time to finally generate your scaffold. Enter this command:

<pre class="brush:ruby">
rails generate nifty:scaffold Product title:string price:integer description:text image_url:string
</pre>

Reading that line out loud would sound like "run the generator named @nifty:scaffold@ and tell it to create an object named @Product@ that has a @title@ which is a @string@, a @price@ which is an @integer@, a @description@ that is @text@, and a @image_url@ that is a @string@"  The generator will then create about 30 files and directories for you based on this information.

h4. Setting up the Database

Now, in your browser, go to "http://localhost:3000/products":http://localhost:3000/products.  Hopefully you get an error screen that starts off like this:

<pre class="console">
ActiveRecord::StatementInvalid in ProductsController#index
SQLite3::SQLException: no such table: products: SELECT * FROM "products" 
</pre>

The second line really tells us what the problem is -- @no such table: products@.  Our database doesn't have a @products@ table yet.  Look in the @/db/migrate@ folder of your project, and open the file that ends @create_products.rb@.

This file is called a *migration*.  It's Rails' way of working with your database to create and modify tables in your database.  It has two sections, @self.up@ which is what it does to create some change in the DB, and @self.down@ which is what it would do to _undo_ those changes.  In the case of our generated @CreateProducts@ migration, in the @self.up@ section you'll see Rails has inserted code to create a table named @products@, then create the @title@, @price@, @description@, and @image_url@ columns with the types we specified.  The @self.down@ just drops the whole table.

This method of modifying the database was one of the big new ideas in Rails.  As we work through the later iterations you'll see why.  For now, you need to run this migration so it actually creates the @products@ table in the database.  In your Terminal, enter the following:

<pre class="console">
rake db:migrate
</pre>

You should see output explaining that it created the table named @products@.  

h4. Creating Sample Products

Now go back to your web browser and refresh the page.  You should get a page that says "Listing Products", click the "New Product" link and it'll bring up a very simple form.  Enter the following data:

* Title: Green Grapes (1 bunch)
* Price: 200
* Description: 1 bunch of approximately 80 green grapes.
* Image_url: green_grapes.jpg

Click @Create@.  If everything looks good on the next page, click the @Back@ link.  Click the "New Product" link and enter the second product:

* Title: Purple Grapes (1 bunch)
* Price: 225
* Description: 1 bunch of approximately 90 purple grapes.
* Image_url: purple_grapes.jpg

Create it and look at your products listing.  Now you have a web store!  (NOTE: The images will be missing for now, that's ok!)

h4. How does Rails do that Magic?

Let's take a peek at how this is all working.  Browse your project files and look at the following files:

* @config/routes.rb@<br/>When you request a page from the application this is the first place Rails goes.  See the line @resources :products@?  Resources are things that follow the RESTful web conventions.  For instance, if the router gets a request for @/products/@ it should look in the @products_controller.rb@ for a method named @index@
* @app/controllers/products_controller.rb@<br/>After finding the @products@ entry in the Routes file, Rails knows to come to this file and run the @index@ method.  You'll see the @index@ method like the code below.  The second line is the most important -- it reads "Find all the Products and stick them in the variable @@products@".

<pre class="brush:ruby">
  def index
    @products = Product.all
  end
</pre>

* @app/views/products/index.html.erb@<br/>This is the view template which is responsible for creating the HTML sent to the browser.  The template is written in a format named *erb* which allows us to mix HTML and Ruby.  The first few lines of this files just look like plain HTML.  On line 10, though, you see some erb syntax.  Look at the example below.  See the @<%@ and @%>@ in line 11?  Those tags mark the beginning and end of Ruby code inside the erb file.  Basically they mean "evaluate whatever code is between these markers as though it were part of a Ruby program."  Then in line 13 you see a variation where the opening tag has an equals sign like this: @<%=@.  When there is *no* equals sign, the code between the markers is run *silently*.  When the beginning marker has the _equals sign_, erb will *output* the result of the code into the HTML.

<pre class="brush:ruby">
<h1>Listing products</h1>

<table>
  <tr>
    <th>Title</th>
    <th>Price</th>
    <th>Description</th>
    <th>Image_url</th>
  </tr>

<% @products.each do |product| %>
  <tr>
    <td><%=h product.title %></td>
    <td><%=h product.price %></td>
    <td><%=h product.description %></td>
    <td><%=h product.image_url %></td>
    <td><%= link_to 'Show', product %></td>
    <td><%= link_to 'Edit', edit_product_path(product) %></td>
    <td><%= link_to 'Destroy', product, :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>
</pre>

Now you've got a database-driven web application running and Iteration 0 is complete.

h2. Iteration 1: Basic Product Listings

So now you might be impressed with yourself.  You've got a web store just about done, right?  Real stores have a ton of _information_ ...pictures, data, reviews, categories not to mention the ability to actually *buy* something.  We'll get there -- for now let's make our store look a little more respectable.

h4. Working with Layouts

In the first iteration I lied to you about how the view step works.  When you're looking at the products listing, Rails isn't just grabbing the @index.html.erb@.  It's also looking in the @/app/views/layouts/@ folder for a *layout* file.  Expand that directory in RubyMine and you'll see that the scaffold generator created a file named @application.html.erb@ for us.

You can think of a layout like a wrapper that is put around each of your view templates.  Layouts allow us to put all the common HTML in one place and have it used by all our view templates.  For instance, it'd be a pain to have to write out the whole @<head>@ section in each of our ERB templates.  Open the layout file and you'll see a lot of the HTML framework is already in the layout file.

If you're on Amazon each of their pages has a certain look and feel.  They have common navigation, stylesheets, titling, etc.  The layout is where we take care of these common elements.  In the @<head>@ section of the layout it currently has line with a @<title>@ -- change it so it reads like this: 

<pre class="brush:ruby">  
  <title>FoodWorks - Products: <%= controller.action_name %></title>  
</pre>

Hit save, switch back to your browser with the product listing, and hit refresh.  The title of your browser tab should now say "FoodWorks - Products: index".  Then click the @New product@ link.  The window title should now say "FoodWorks - Products: new".  Even though the @index@ and @new@ actions have different view templates they share the same layout, so the change we made shows up in both places.  Let's add a little more to the layout file...

* Look for the existing @stylesheet_link_tag@ line on line 5.  Change it so it looks like this: @<%= stylesheet_link_tag 'styles' %>@.  That tells Rails to pull a stylesheet names @styles.css@ from our stylesheets directory.  I'll give you the stylesheet and you can put it into your project's @/public/stylesheets/@ folder.
* Next let's add a little structure to our pages to make CSS styling easier.  Modify everything from @<body>@ to @</body>@ so it matches the code below:

<pre class="brush:html;">
<body>
<p style="color: green"><%= flash[:notice] %></p>
<div class="wrapper">
    <div class="header">
      <h1>FoodWorks</h1>
      <p>Your Online Grocery</p>
    </div>

    <div class="sidebar">
      (sidebar)  
    </div>

    <div class="main">
      <%= yield %>
    </div>
 
    <div class="footer">
      FoodWorks Online Grocery<br/>
      A Rails Jumpstart Project
    </div>
</div>
</body>
</pre>

Now save your layout and refresh the products listing.  It should look a little prettier, but we haven't changed much about the content yet.  

h4. Editing a View Template

Let's open the @/app/views/products/index.html.erb@ view template so we can make some changes.

* Change the title to H1 tags with the text "All Products"
* The link at the bottom is currently "New product" -- let's change it to "Create a New Product" like this:

<pre class="brush:ruby">
  <p><%= link_to "Create a New Product", new_product_path, :id => "new_product" %></p>
</pre>

* Then let's restructure the table.<br/> See the line that says @<% for product in @products %>@?  That means "for each of the things in the variable @@products@, take them one at a time, call them @product@, then do everything in between this line and the one that reads @<% end %>@"<br/>So for each @product@, the existing template creates one TD for the @title@, one for the @price@, one for the @description@ and so on.  Let's simplify the products like this:

<pre class="brush:ruby">
<% for product in @products %>
  <tr>
    <td><%= image_tag "/images/products/#{product.image_url}" %></td>
    <td><span class="product_title"><%= product.title %></span><%= product.description %></td>
    <td><%= product.price %></td>
  </tr>
<% end %>
</pre>

Try looking at the page in your web browser.  Rework the table's THs to match up with the new TDs.

Then I'll send you a few product images in a zip file.  Move the images into @/your_project/public/images/products/@.

Save that and check out your products index at "http://localhost:3000/products":http://localhost:3000/products.

h4. Fixing the Price Display

When you look at the products index the price probably looks kind of silly.  No one shops in cents, right?  Let's clean it up with a view helper.

A helper, in Rails, is some code that helps you do common operations to data as part of the presentation.  We want to make a helper where we can send in a number like "225" and it gives us back "$2.25", the format our shoppers are anticipating.

* Open the file @/app/helpers/products_helper.rb@
* Between the line that starts with @module@ and the @end@, add this method:

<pre class="brush:ruby">
  def print_price(price)
    format("$%.2f",price/100.0)
  end
</pre>

This formatting code is kind of ugly, I had to look it up to remember exactly how it works.  That's why we create a helper -- so now you don't need to remember how it works, just call the @print_price@ method and it takes care of the hard work.  Go back to your @index.html.erb@ file and change @<%= product.price %>@ to @<%= print_price(product.price) %>@.  Save it and refresh your products display.  Your store is starting to look good!

h4. Linking to the Product Page

When you're on the index page there's no way to get to the "show" page for an individual product.  Go back to the @index.html.erb@ and use the @link_to@ helper to insert links to the show page.  @link_to@ requires two parameters: what the link should *say* and where it should *point*.  To trigger a show action, point the link towards @product_path(product)@.

h4. Working on the New Product Page

Click the @Create a New Product@ link on your index page.  Rails will access your @products_controller@, find the @new@ method, run that code, then load the @new.html.erb@ view template.  Open that ERB file and you'll see there isn't much there.

Change the title to an H1 that reads "Create a New Product." Then to manipulate the form itself we'll need to jump into @_form.html.erb@.

* Look at the line @<%= f.label :price %><br />@.  This tells Rails to create an HTML @label@ for the thing named @:price@ and, by default, it puts the text @Price@ there.  We want it to say "Price (enter in cents)" instead.  We add in the desired text as a second parameter like this: @<%= f.label :price, "Price (enter in cents)" %><br />@
* Save your ERB and reload your form to make sure everything is looking ok

Create a new product and enter in this information EXACTLY:
* Title: Oranges
* Price: $2.99
* Description: Bag of 6 Valencia oranges.
* Image_url: oranges.jpg

Click @Create@ then look at the page you get back.  

h4. Validating the Price

What's up with the price?  Is that what you expected?

We tried to put "$2.99" to the database, but it's expecting a number, not something with a dollar sign and a period.  How can we help the user not make this mistake?  Adding a validation.

* Open the file @/app/models/product.rb@
* Before the class' @end@, add this validation:<br/>@validates_numericality_of :price@
* Get back to your product listing and @destroy@ the oranges that we just created
* Click @Create a New Product@ and enter the orange information just as we did above and click @Create@

Now you should see some great things that Rails does for "free".  It keeps us on the product creation screen, it tells us that there was a problem, it tells us what the problem is, then it highlights both the label and the form field in red.  Makes it pretty clear, right?  Take off the dollar sign so your price just says "2.99" and click @Create@ again.

The error is gone, but now our price is "2"?!?  If we're storing our prices in cents, then two cents per bag is going to be a little on the cheap side.  What happened?

We put in the number "2.99".  Rails did the validation we requested and confirmed that "2.99" is a number so it created the product.  But the database was expecting an integer, a number with no decimal point.  So when it gets the "2.99" it basically says "I don't care about your decimal point...the number will just be 2" -- it truncates the decimal.  Sounds like we need to modify our validation!  Go back to the @product.rb@ and modify the validation so it looks like this:

<pre class="brush:ruby">
validates_numericality_of :price, :only_integer => true, :message => "should be entered in cents."
</pre>

Destroy your two-cent oranges and try creating them again with the prices "$2.99", "2.99", then "299".

Look at the folder of images that you copied over to see some other products you might create.  Make at least 5 products for your store.

Iteration 1 is complete!

h2. Iteration 2 - Handling Stock

Any good store needs to manage stock.  When customers are shopping they should be able to see the current stock.  When people buy something, the stock goes down.  Administrators should be able to arbitrarily change the stock count.

h4. Modifying the Database

Anytime we're tracking new data we'll need to modify the database.  Jump over to your Terminal and generate a migration with this command:

<pre class="console">
rails generate migration add_stock_to_products
</pre>

After it generates, open the migration (look in @/db/migrate@) and in the @self.up@ add the line below.

<pre class="brush:ruby">
add_column :products, :stock, :integer, :default => 0
</pre>

Then in the @down@ add the opposite:

<pre class="brush:ruby">
  remove_column :products, :stock
</pre>

Run the migration with @rake db:migrate@ then the column exists in your database.  

h4. Adding to the Products Listing

Let's open up the view for our products index (@/app/views/products/index.html.erb@) and add in a column after @Price@ for @Stock@ in the THs.  Down in the TDs, write this:

<pre class="brush:ruby">
<td><%= print_stock(product.stock) %></td>
</pre>

So that's expecting to use the helper method named @print_stock@.  Here's the logic we want to implement:

* If the product is in stock, print the following where ## is the number in stock:
** &lt;span class='in_stock'&gt;In Stock (##)&lt;/span&gt;
* If it's out of stock, print the following:
** &lt;span class='out_stock'>Out of Stock&lt;/span&gt;

Go into the @products_helper.rb@ and create a method named @print_stock@ then fill in the blank lines with the stock messages:

<pre class="brush:ruby">
def print_stock(stock)
  if stock > 0
    
  else
    
  end
end
</pre>

With the helper implemented refresh your products index and you should see all products out of stock.

h4. Making the Stock Editable

Hop into the @Show@ page for your first project then click the @Edit@ link.

This edit form only shows the original fields that were there when we ran the scaffold generation, but it's easy to add in our stock.  Open the form template at @/app/views/products/_form.html.erb@

Using the title and price as examples, write a paragraph for the stock including the label and a text field. Refresh your web browser and you should see the stock field available for editing.

Since it's just a raw text field, let's add some validation to the @product.rb@ model to make sure we don't put something crazy in for the stock.  Check out the Rails API documents here "http://ar.rubyonrails.org/classes/ActiveRecord/Validations/ClassMethods.html":http://ar.rubyonrails.org/classes/ActiveRecord/Validations/ClassMethods.html and figure out how to write ONE validation that makes sure:

* Stock is a number
* Stock is an integer
* Stock is greater than or equal to zero

Once your validation is implemented, give it a try with illegal values for @Stock@ like @-50@, @hello!@, and @5.5@. Is it failing?

h4. Dealing with @attr_accessor@

Your validation probably isn't working, right?  Your form isn't changing the value of stock, but it also isn't showing a validation error.  What's up?

Take a look in the @Product@ model again.  See the first line about @attr_accessible@?  This method all declares which of the model's attributes allow "mass-assignment."  Both our @edit@ and @new@ forms are setup to use mass-assignment, and since @stock@ isn't in this list the data from the form is getting ignored.

Add @stock@ to the @attr_accessible@ list and retry your good and bad stock values.  

With those validations implemented, add stock to most of your products so we can do some shopping.

Iteration 2 is complete!

h2. Iteration 3: Designing Orders

We've got products, but until we have a way to create orders then our store isn't going to make any money.

h3. Brainstorming the Data Structure

Let's think about what an "order" is:

* It's a collection of products to purchase
** Each of those has a quantity and a unit price
* It has a total price
* It has a customer
* It has a status like "unsubmitted", "needs_payment", "needs_packing", "needs_shipping", and "shipped"

Looking at this from the database perspective, we'll need two objects:

* @OrderItem@<br/>One piece of an order, this will be a single product ID and a quantity of how many are being ordered
** @product_id@: (integer) the @Product@ that this @OrderItem@ is referencing
** @order_id@: (integer) the @Order@ that this @OrderItem@ is referencing
** @quantity@: (integer) the quantity of this product desired 
* @Order@<br/>It will have many @OrderItem@ objects, belong to a customer ID, and have a status code
** @customer_id@: (integer) the customer that this order belongs to
** @status@: (string) the current status of the order

With that in mind, go to your Terminal and generate some scaffolding and migrate the database:

<pre class="brush:ruby">
rails generate nifty:scaffold OrderItem product_id:integer order_id:integer quantity:integer
rails generate nifty:scaffold Order customer_id:integer status:string
rake db:migrate
</pre>

h3. The Data Models

From there we need to build up our two data models and express their relationships.

h4. The @OrderItem@ Model

Then jump into @/app/models/order_item.rb@ and we'll work on relationships.  Since the @OrderItem@ holds a foreign key referencing an @Order@, we'd say that that it @belongs_to@ the @Order@.  Add the relationship to the model like this:

<pre class="brush:ruby">
class OrderItem < ActiveRecord::Base
  attr_accessible :product_id, :order_id, :quantity
  belongs_to :order
end
</pre>

There's also a relationship between an @OrderItem@ and a @Product@.  A @Product@ is going to be ordered many times, we hope, but an @OrderItem@ is only going to connect with a single @Product@.  This is a "One-to-Many" relationship where one @Product@ is going to have many @OrderItems@ and an @OrderItem@ is going to @belong_to@ a product.

Add the second @belongs_to@ relationship in @order_item.rb@

Then, let's add a validation to make sure that no @OrderItem@ gets created without an @order_id@ and a @product_id@.  Use @validates_presence_of@

h4. The @Order@ Model

Next, let's turn our attention to @/app/models/order.rb@ .  We said previously that an @OrderItem@ would @belong_to@ an @Order@.  Now we have to decide, should an @Order@ have only one @OrderItem@ or multiple?

We definitely want people ordering as many products as they want, so an @Order@ should have many @OrderItems@!  Add it like this:

<pre class="brush:ruby">
class Order < ActiveRecord::Base
  has_many :order_items
end
</pre>

h3. Implementing an Order Workflow

That was the easy part.  Now it's going to get tricky.  

h4. Add to Cart Links

Let's open the @index@ view for our @products@ (@/app/views/products/index.html.erb@).  How do we want the shopping process to work? Each product description should have an "Add to Cart" link that adds that item to the customer's cart.  Once they click that the customer should be taken to their order screen where they can set quantities and checkout.

First we'll create the "Add to Cart" link.  In the @<th>@ lines near the top of the index add @<th>Buy</th>@.  Then in the TDs, underneath the stock line, let's add a new cell:

<pre class="brush:ruby">
<td><%= link_to "Add to Cart", new_order_item_path(:product_id => product.id) %></td>
</pre>

This says "create a link with the text 'Add to Cart' which links to the new @order_item@ path and sends in a parameter named @product.id@ with the value of the ID for this @product@.

Reload the index in your browser and you new links should show up.

h4. Tracking an Order

When you click the "Add to Cart" link you see a plain scaffolding form prompting the user for the product id, order id, and quantity.  That's not acceptable.

When the user clicks "Add to Cart", the system should:

* Find or create a new @Order@ for the current visitor
* Add the item to the @Order@ with a quantity 1

The first part is tricky because HTTP is a stateless protocol.  There isn't any continuity between requests, so it's hard to identify a user between requests.  But in situations like this one, we need to keep track of users across many page clicks.  

We'll take advantage of Rails' session management here.  The session will allow us to track data about a user across multiple requests.

h4. Managing Orders in a Before Filter

Open your @/app/controllers/products_controller.rb@ file.  This controller is what handles the "operations" of a web request.  The request starts at the router (or @routes.rb@ file), gets sent to the correct controller, then the controller interacts with the models and views.  Think of the controller as the "coach" -- it calls all the shots.  At the top of the controller file, just below the @class@ line, add this code:

<pre class="brush:ruby">
  before_filter :load_order

  def load_order
    begin
      @order = Order.find(session[:order_id])
    rescue ActiveRecord::RecordNotFound
      @order = Order.create(:status => "unsubmitted")
      session[:order_id] = @order.id
    end
  end
</pre>

First, we're declaring a @before_filter@.  This first line tells Rails "before every request to this controller, run the method named @load_order@".  

We then define the method named @load_order@.  Rails provides us access to the user session through the @session@ hash.  This method tries to find the @Order@ with the @:order_id@ in the session and stores it into the variable named @@order@.  If the @session@ hash does not have a key named @:order_id@ or the order has been destroyed, Rails will raise an @ActiveRecord::RecordNotFound@ error.  The @rescue@ statement watches for this error and, if it occurs, creates a new @Order@, stores it into the variable @@order@, and saves the ID number into @session[:order_id]@.

With that code in place refresh your Products index and...nothing looks different.  Rails has silently created an @Order@ and saved the ID number into a cookie in your browser.  To verify that an order got created, open a second web browser tab and load @http://localhost:3000/orders/@ where you should see a single unsubmitted order.  

h4. Now Add the Product to the Order

Go back to your products list and click the "Add to Cart" link for one of your products.  You still see the blank form, right? We think the @@order@ is setup by the @before_filter@, but we're not seeing it's ID here.

Looking at the @OrderItemsController@, the link is triggering the @new@ action.  In Rails' implementation of the REST pattern, the @new@ action shows the form and the @create@ action processes the form data.

In our use case, we can actually just skip the form. When the user clicks the "Add to Cart" link we know their @order_id@ from the session, we know the @product_id@ based on which link they clicked, and we'll assume that they want to start with a quantity of 1.

So let's get rid of the @new@ action from the controller.  While we're cutting code, we won't need the @show@ or @index@ actions either, so delete them!

We need the products index to trigger the @create@ action. Look at the routes table (by running @rake routes@ from the terminal) and see that we need a @POST@ request to @order_items_path@. To generate a @POST@ we have to use a form, but our product listing uses links for the "Add to Cart". Open the index template and just change the @link_to@ to a @button_to@ like this:

<pre class="brush:ruby">
  <td><%= button_to "Add to Cart", order_items_path(:product_id => product.id) %></td>
</pre>

Refresh your browser, click an "Add to Cart" button, and you should see a form complaining about validation errors.

h4. Rewriting the Create Action

Look at the server log for the last request.  You should see "Started POST" because the button triggered a POST action, then look at the parameters line.  See the @product_id@ in there?  We have all the information we need to rewrite the @create@ action.  The @create@ currently looks like this:

<pre class="brush:ruby">
  def create
    @order_item = OrderItem.new(params[:order_item])
    if @order_item.save
      redirect_to @order_item, :notice => "Successfully created order item."
    else
      render :action => 'new'
    end
  end  
</pre>

The first line is trying to create an @OrderItem@ from form parameters, but they're not there. Instead we can build the @OrderItem@ through the relationship with the @order@.  Wait, do we have an @@order@ setup for this controller?

h4. Relocating the @load_order@ Method

The @load_order@ before filter exists in the @ProductsController@ but not in the @OrderItemsController@.  We have to copy/paste code, so how can it be shared between both controllers?

If you look at the first line of each controller, they inherit from the @ApplicationController@ class.  Cut the @load_order@ definition from @ProductsController@ and move it over to @ApplicationController@.

Now it's available to both controllers, so in the @OrderItemsController@ you can call @before_filter :load_order@

h4. Building the @OrderItem@

Now that we have access to @@order@, we can build the @order_item@ through the relationship like this:

<pre class="brush:ruby">
  def create
    @order_item = @order.order_items.new(:quantity => 1, :product_id => params[:product_id])
    if @order_item.save
      redirect_to @order, :notice => "Successfully created order item."
    else
      render :action => 'new'
    end
  end  
</pre>

The @order_id@ will be set by the relationship, then we explicitly set the @quantity@ to one and the @product_id@ comes from the request parameters.  Then, if the item is successfully saved, redirect to the @order@.

Go back to your products @index@ page, click an "Add to Cart" button.

h3. Displaying an Order

You should now be redirected to @http://localhost:3000/orders/1@ which is your current order.  You're looking at the order, you think some products have been added, but we're not doing anything to display them yet.  

Add this snippet somewhere on the page:

<pre class="brush:ruby">
  <p>
    Item Count: <%= @order.order_items.count %>
  </p>
</pre>

Reload the page and you should see the *Items* display 1.  Go back to your products listing and click "Add to Cart" to add more items.  You should see this counter increasing each time.

Our shopping experience has a long way to go, but it's getting there.  Iteration 3 is complete!

h2. Iteration 4: Improving the Orders Interface

We'll continue working on our @/app/views/orders/show.html.erb@ so open it in your editors and load an order in your web browser.

h3. Reworking the Order's @show@ View

Replace the code in the @show.html.erb@ with this:

<pre class="brush:ruby">
  <h1>Your Order</h1>

  <table>
    <tr>
      <th>Customer</th>
      <td><%= @order.customer_id %></td>
    </tr>
    <tr>
      <th>Status:</th>
      <td><%= @order.status %></td>
    </tr>
    <tr>
      <th>Items:</th>
      <td><%= @order.order_items.count %></td>
    </tr>
    <tr>
      <th>Items</th>
      <th>Title</th>
      <th>Quantity</th>
      <th>Unit Price</th>
      <th>Subtotal</th>
    </tr>
    <!-- more code will go here -->  
  </table>
</pre>

Save that then refresh your order view.  The basics are there, but it still isn't showing what items are in the order.  

h4. Displaying Individual Items in an Order

Remember when we declared that an @Order@ @has_many@ @OrderItems@?  We did that so we could easily access an order's items.  Remove the line that says @<!-- more code will go here -->@ and replace it with this:

<pre class="brush:ruby">
  <% @order.order_items.each do |item| %>

  <% end %>
</pre>

Inside those lines put whatever HTML and data code you want rendered for @each@ item in the @@order@.  Follow the headings that already exist.  You'll need to...

* Create a new TR that contains...
** A blank TD
** The @item.product.title@ in a TD
** The @item.quantity@ in a TD
** The @item.product.price@ in a TD and use the @print_price@ helper
** A blank TD, temporarily, for the subtotal

Refresh your view and you should see your individual @OrderItems@ listed out.

h4. Displaying Product Images

Integrate images of the products into your order display into the first TD of the row.  As you did in the products listing, the image can be inserted by using Rails' @image_tag@ helper method along with the path to the image (which the @Product@ model stores).  Try and figure this out on your own, but if necessary go look at your @/app/views/products/index.html.erb@ file.

h3. Order Calculations

We need to both calculate the subtotals for individual items and the total cost for the entire order.

h4. @OrderItem@ Subtotal

The subtotal is the easier part because it only involves one object, the @OrderItem@.  We can ask an @OrderItem@ to output its subtotal like this:

<pre class="brush">
  <%= print_price item.subtotal %>
</pre>

If you refresh that will crash because it's expecting @item@ to have a method named @subtotal@.  Open the @OrderItem@ model and define a method named @subtotal@ that returns the quantity times the product's price.

When you think you've got it, refresh the view and check out your results.  It's not conclusive since our quantities are all 1 right now, but it's a start.

h4. Calculating the Order Total

Now we're displaying the individual items and their costs, but we don't have a total for the order.  Let's open the @Order@ model (@/app/models/order.rb@) and create a method named @total@.  Our @OrderItem@ model already implements a @subtotal@ method that gives us the total for that single item, so what we need to do is add up the @subtotal@ from each of the @order_items@ in this order.  

I'm going to leave that up to you!

With that method written, go back to your order's @show@ view and add another line at the bottom with a TH that says "Order Total" and a TD that displays the total.  Remember to use your @print_price@ helper method to get the right formatting.

h3. Manipulating the Order

We can add items to the order, but we can't remove them!

h4. Removing a Single Item from the Order

Let's add a "remove" link for each item in the order.

Removing a single item from the order is actually pretty easy.  To get a hint, let's look at some scaffolding views that we aren't actually using.  Open up @/app/views/order_items/index.html.erb@.  See on line 17 how it makes the "Destroy" link?  Let's grab that whole line.  

Move back to your order's @show@ template go to the area where you're displaying the individual order items.  Modify your table to make an appropriate space for a "remove" link and paste in the code we got from the other template.  You can change the word "Destroy" to "Remove" be less dramatic. Also change @order_item@ to @item@, since that's what we called it in that view's @each@ block.

Click one of the delete links and it almost works.  The @delete@ action in @OrderItemsController@ is being triggered, but after destroyin the object it redirects to the @index@ of @OrderItemsController@.  Instead, make it redirect to the @Order@, then go back and try deleting another item.

h4. Clearing All Items from an Order

Deleting a single item was easy, but deleting all of them? We have two options:

# Create a custom @empty@ action in @OrdersController@ and have it loop through destroying the individual @OrderItems@
# Just destroy the Order

I like easy, so let's pick #2!

On the @show@ view for your @Order@, add a link like this:

<pre class="brush:ruby">
  <%= link_to "Empty Cart", @order, :confirm => 'Are you sure?', :method => :delete %>
</pre>

Hop into the @destroy@ action of @OrdersController@ and change the redirect so it sends you back to @products_path@.

Then give it a try. When it works, Iteration 4 is complete!

h2. Iteration 5 - Dealing with Order Quantities

Our order screen is getting powerful, but there are still some features we should add around managing quantities.

h4. No Double-Items

I'm sure you noticed that items are getting to the cart each time the user click "Add to Cart".  We don't want two listings for Green Grapes, we want one @order_item@ with a quantity of two.  No problem!

This is how it should work:
* When the user clicks the Add to Cart button...
** If that product is already in the order, increase the quantity by one
** If it's not in the order, add it to the order with quantity one

Look at the @create@ method in your @order_items_controller@.  The first line is always creating a new @OrderItem@, but we want to look for one with the matching @product_id@ first.  We could do this ourselves with and @if@ statement, but let's take advantage of Rails' @find_or_initialize_by@ like this:

<pre class="brush:ruby">
  @order_item = @order.order_items.find_or_initialize_by_product_id(params[:product_id])
</pre>

We can give @find_or_initialize_by@ any attribute name of the object, in this case @product_id@, and pass in the @product_id@ we're looking for.  If there is a matching @OrderItem@ already attached to this @Order@ with this @product_id@, it'll find it and give it back to us.  If it doesn't exist, one will be created.

Try using this in your browser.  As you add products to your cart you should see that items to not get repeated, but the quantity is not yet going up when we add the same product twice.

h4. Incrementing Repeated Items

If the finder is creating a new @OrderItem@, we want to set the quantity to 1.  If it finds an existing @OrderItem@, we want to just increment it by one.  We can do both of these in one instruction *if* the default @OrderItem@ quantity is zero.

We set the default value in the database, and to change the database we'll need a migration.  From your command line:

<pre class="console">
  rails generate migration add_default_value_to_order_items_quantity
</pre>

Then open that migration and in the @up@ method add this line:

<pre class="brush:ruby">
  change_column :order_items, :quantity, :integer, :default => 0
</pre>

No @down@ is necessary for this little tweak. Run the migration with @rake db:migrate@.  If you'd like to see the results, create a new @OrderItem@ from your console and you'll see it starts with the quantity 0.

Now that the default value is set, your @create@ action in @OrderItemsController@ can just increment the quantity by one without caring what the initial value is.

Try adding an item to your cart multiple times and you should see the quantities, subtotal, and total moving up!

h3. Managing Quantities in the Order

We never made a way for customers to easily modify the quantity of each item in the order.  Let's implement that now.  There are several ways we could do this from an interface perspective.  We'll do it in a way that's easy for us as new Rails programmers.

Look at the @show@ template for the @order@.  Find the TD where we currently just print out the quantity for that item.  Let's change it to a link like this:

<pre class="brush:ruby">
<td><%= link_to item.quantity, edit_order_item_path(item) %></td>
</pre>

That says "create a link with the text of the link displaying the item's quantity and the link pointing to the @edit_order_item@ action and tell it that we want to edit the item named @item@".  Save and refresh your browser.  Click one of the resulting links under quantity.

h4. Cleaning Up the Order Items Edit

You are back to some ugly scaffolding code and this form is way too flexible.  We don't want people changing the product ID or the order ID, just the quantity.  Open the @form@ partial for @order_item@ (@/app/views/order_items/_form.html.erb@) and make the following changes:

* Remove the @label@ and @text_field@ for @product_id@ and, instead, just print out the product's title (@@order_item.product.title@)
* Remove the whole section for the @order_id@.  It doesn't need to be displayed or editable.

Refresh your page and make sure the form is displaying properly.  Enter the quantity desired as @5@ then click Update.

It worked, kind of.  It saved the new quantity, but the controller tries to bounce you to the @show@ template for @order_item@.  What we'd really like is to bounce back to the @show@ for the @order@.  Open up @/app/controllers/order_items_controller.rb@.  Scroll down to the @update@ method, and change the @redirect_to@ so it points to the @Order@.

Now it has a reasonable workflow.  Try changing the quantities of your different @order_items@.

h4. Remove Items with 0 Quantity

Sometimes instead of clicking "remove" to remove an item from an order, users will set the quantity to zero.  Try doing this now with one of your existing orders.  What happens?

To tell you the truth, I expected an error.  We put in a validation that @order_item@ couldn't have a zero or negative quantity because that wouldn't make any sense -- right?  Right?  Nope, missed it.  Open up your @/app/models/order_item.rb@ and add a validation that ensures @quantity@ is a number, an integer, and greater than zero.

Now go back to your order screen, edit an item's quantity to zero, then click update.  You should get an error message sending you back to the edit form saying that @quantity@ must be greater than zero.  Good.

Now look at @/app/controllers/order_items_controller.rb@ and specifically the @update@ method.  We want to short-circuit this process if the incoming @params[:order_item][:quantity]@ is zero.

Restructure the logic with a conditional statement like this:

* find the @order_item@ by the @id@
* if @params[:order_item][:quantity].to_i@ is equal to zero
** destroy the @order_item@
** redirect to the order and set the @flash@ to say that the item was removed
* elsif the attributes successfully update...
** redirect to the @Order@ with a notice @"Successfully updated the order item"@
* else
** display the edit form again

Test it out and confirm that setting the quantity to zero removes an item from the order.

h3. More Intelligent Stock Checking

Now that we can make all these changes to the quantity being ordered it makes our current stock checking a little ineffective.  If there's at least one of an item in stock, our app will say it's "in stock".  But if the customer is trying to order more than the current stock, we should change that notification.

h4. Displaying Stock on the Order Page

Let's start by opening the @/app/helpers/products_helper.rb@ file and finding the @print_stock@ method we created earlier.  We want to create logic like this:

* if there is enough stock to fulfill the requested number
** return the "in stock" line
* else if there is some stock, but not enough to fulfill the requested number
** return this: @&lt;span class="low_stock"&gt;Insufficient Stock (##)&lt;/span&gt;@
* else
** return the "out of stock" line

But how will the helper know what quantity the current order is requesting?  We'll have to add a second parameter.  So change 

<pre class="brush:ruby">
def print_stock(stock)
</pre>

...to...

<pre class="brush:ruby">
  def print_stock(stock,requested)
</pre>

Then use the @requested@ variable to implement the logic above.

Go back to your your @show@ view template for @orders@ (@/app/views/orders/show.html.erb@).  Try to add in a column to the display that prints out the stock status of each of the items in the order.  Here are the steps you need to do:

* Add the header for @Stock@ between @Quantity@ and @Unit Price@
* Add the TD that calls the helper method @print_stock@ and passes in the value of this item's product's stock and the quantity requested from this @order_item@

Refresh your browser and confirm that it's working.  Try setting your quantities to trigger the "Insufficient Stock" message.

h4. Displaying Stock on the Products Index

Now go back to your Products listing page.  Problem?  Your products listing is also trying to use that @print_stock@ helper, but it's just sending in one parameter.  Now we're getting the error message that the method is expecting two parameters.  How to fix it?  There are two ways.

The ugly way would be open the products @index@ view and change our call to the helper, adding in a @0@ for the number requested.  That'd work, but we don't like ugly.  If we end up using the helper anywhere else, we'd have to remember to always put in this hack.

Instead we'll improve the helper, so switch back to that file.  Ruby has a great way of implementing optional parameters.  We can set it up so calling the helper with one parameter will print whether or not the item is in stock, and sending in two parameters will check if there's sufficient stock.  All we need to do is change...

<pre class="brush:ruby">
  def print_stock(stock, requested)
</pre>

to...

<pre class="brush:ruby">
  def print_stock(stock, requested = 1)
</pre>

With that change, if we send in a value for @requested@ the method will use it.  If we don't send in a value for @requested@, and thus have only one parameter, it'll just set requested to zero.  This will allow our product listing to work just like it did before and our order page to have the smarter sufficient-quantity check.

Test it out and, when it works, we're done with iteration 5!

h2. Iteration 6: Establishing Identity

What's the point of a web application if only one person can use it?  Let's make our system support multiple users.  There are three pieces to making this happen:

* *Authentication* - Establish identity
* *Ownership* - Attach data records to user records
* *Authorization* - Control who is allowed to do what

h3. Background on Authentication

There have been about a dozen popular methods for authenticating Rails applications over the past five years.  

The most popular right now is "Devise":https://github.com/plataformatec/devise because it makes it very easy to get up and running quickly.  The downside is that the implementation uses very aggressive Ruby and metaprogramming techniques which make it very challenging to customize.

In the past I've been a fan of "AuthLogic":https://github.com/binarylogic/authlogic because it takes a very straightforward model/view/controller approach, but it means you have to write a lot of code to get it up and running.

As we learn more about constructing web applications there is a greater emphasis on decoupling components.  It makes a lot of sense to depend on an external service for our authentication, then that service can serve this application along with many others.

h3. Why OmniAuth?

The best application of this concept is the "OmniAuth":https://github.com/intridea/omniauth.  It's popular because it allows you to use multiple third-party services to authenticate, but it is really a pattern for component-based authentication.  You could let your users login with their Twitter account, but you could also build our own OmniAuth provider that authenticates all your companies apps.  Maybe you can use the existing LDAP provider to hook into ActiveDirectory or OpenLDAP, or make use of the Google Apps interface?

Better yet, OmniAuth can handle multiple concurrent strategies, so you can offer users multiple ways to authenticate.  Your app is just built against the OmniAuth interface, those external components can come and go.

h3. Getting Started with OmniAuth

The first step is to add the dependency to your @Gemfile@:

<pre class="brush:ruby">
  gem "omniauth"
</pre>

Then run @bundle@ from your terminal.

OmniAuth runs as a "Rack Middleware" which means it's not really a part of our app, it's a thin layer between our app and the client.  To instantiate and control the middleware, we need an initializer.  Create a file @/config/initializers/omniauth.rb@ and add the following:

<pre class="brush:ruby">
  Rails.application.config.middleware.use OmniAuth::Builder do
    provider :twitter, "i0KU4jLYYjWzxpTraWviw", "djMu7QStnBK89MkfIg78tIZ4sFhmGOYjdCjDD0Wsc"
  end
</pre>

What is all that garbage?  Twitter, like many API-providing services, wants to track who's using it.  They accomplish this by distributing API accounts.  Specifically, they use the OAuth protocol which requires a "comsumer key" and a "consumer secret."  If you want to build an application using the Twitter API you'll need to "register and get your own credentials":https://dev.twitter.com/apps.  For this tutorial, I've registered a sample application and given you my key/secret above.

h3. Trying It Out

You need to *restart your server* so the new library and initializer are picked up.  In your browser go to @http://127.0.0.1:8080/auth/twitter@ and, after a few seconds, you should see a Twitter login page.  Login to Twitter using any account, then you should see a *Routing Error* from your application.  If you've got that, then things are on the right track.

If you get to this point and encounter a *401 Unauthorized* message there is more work to do.  You're probably using your own API key and secret.  You need to go into the "settings on Twitter for your application":https://dev.twitter.com/apps/, and add @http://127.0.0.1@ as a registered callback domain.  I also add @http://0.0.0.0@ and @http://localhost@ while I'm in there.  Now give it a try and you should get the *Routing Error*

h3. Handling the Callback

The way this authentication works is that your app redirects to the third party authenticator, the third party processes the authentication, then it sends the user back to your application at a "callback URL".  Twitter is attempting to send the data back to your application, but your app isn't listening at the default OmniAuth callback address, @/auth/twitter/callback@.  Let's add a route to listen for those requests.

Open @/app/config/routes.rb@ and add this line:

<pre class="brush:ruby">
  match '/auth/:provider/callback', :to => 'sessions#create'
</pre> 

Re-visit @http://localhost:8080/auth/twitter@, it will process your already-existing Twitter login, then redirect back to your application and give you *Uninitialized Constant SessionsController*.  Our router is attempting to call the @create@ action of the @SessionsController@, but that controller doesn't exist yet.

h3. Creating a Sessions Controller

Let's use a generator to create the controller from the command line:

<pre class="console">
  rails generate controller sessions
</pre>

Then open up that controller file and add code so it looks like this:

<pre class="brush:ruby">
  class SessionsController < ApplicationController
    def create
      render :text => request.env["omniauth.auth"]
    end
  end
</pre>

Revisit @/auth/twitter@ and, once it redirects to your application, you should see a bunch of information provided by Twitter about the authenticated user!  Now we just need to figure out what to *do* with all that.

h3. Creating a User Model

Even though we're using an external service for authentication, we'll still need to keep track of user objects within our system.  Let's create a model that will be responsible for that data.  

As you saw, Twitter gives us a ton of data about the user.  What should we store in our database?  The minimum expectations for an OmniAuth provider are three things:

* *provider* - A string name uniquely identifying the provider service
* *uid* - An identifying string uniquely identifying the user within that provider
* *name* - Some kind of human-meaningful name for the user

Let's start with just those three in our model.  From your terminal:

<pre class="console">
  rails generate model User provider:string uid:string name:string
</pre>

Then update the database with @rake db:migrate@.

h3. Creating Actual Users

How you create users might vary depending on the application.  For the purposes of our shopping cart, we'll allow anyone to create an account automatically just by logging in with the third party service.

Hop back to the @SessionsController@.  I believe strongly that the controller should have as little code as possible, so we'll proxy the User lookup/creation from the controller down to the model like this:

<pre class="brush:ruby">
  def create
    @user = User.find_or_create_by_auth(request.env["omniauth.auth"])
  end
</pre>
 
Now the @User@ model is responsible for figuring out what to do with that big hash of data from Twitter.  Open that model file and add this method:

<pre class="brush:ruby">
  def self.find_or_create_by_auth(auth_data)
    user = self.find_or_create_by_provider_and_uid(auth_data["provider"], auth_data["uid"])
    if user.name != auth_data["user_info"]["name"]
      user.name = auth_data["user_info"]["name"]
      user.save
    end    
    return user
  end
</pre>

To walk through that step by step...
* Look in the users table for a record with this provider and uid combination.  If it's found, you'll get it back.  If it's not found, a new record will be created and returned
* Compare the user's name and the name in the auth data. If they're different, either this is a new user and we want to store the name or they've changed their name on the external service and it should be updated here. Then save it.
* Either way, return the user

Now, back to @SessionsController@, let's add a redirect action to send them to the @companies_path@ after login:

<pre class="brush:ruby">
  def create
    @user = User.find_or_create_by_auth(request.env["omniauth.auth"])
    session[:user_id] = @user.id
    redirect_to products_path, :notice => "Logged in as #{@user.name}"
  end
</pre>

Now visit @/auth/twitter@ and you should eventually be redirected to your Products listing and the flash message at the top will show a message saying that you're logged in.

h3. UI for Login/Logout

That's exciting, but now we need links for login/logout that don't require manually manipulating URLs.  Anything like login/logout that you want visible on every page goes in the layout.

Open @/app/views/layouts/application.html.erb@ and you'll see the framing for all our view templates.  Let's add in the following *just below the flash messages*:

<pre class="brush:ruby">
  <div id="account">
    <% if current_user %>
      <span>Welcome, <%= current_user.name %></span>
      <%= link_to "logout", logout_path, :id => "login" %>
    <% else %>
      <%= link_to "login", login_path, :id => "logout" %>
    <% end %>
  </div>
</pre>

If you refresh your browser that will all crash for several reasons.

h3. Accessing the Current User

It's a convention that Rails authentication systems provide a @current_user@ method to access the user.  Let's create that in our @ApplicationController@ with these steps:

* Underneath the @protect_from_forgery@ line, add this: @helper_method :current_user@
* Just before the closing @end@ of the class, add this:

<pre class="brush:ruby">
  private
    def current_user
      @current_user ||= User.find(session[:user_id]) if session[:user_id]
    end  
</pre>

By defining the @current_user@ method as private in @ApplicationController@, that method will be available to all our controllers because they inherit from @ApplicationController@.  In addition, the @helper_method@ line makes the method available to all our views.  Now we can access @current_user@ from any controller and any view!

Refresh your page and you'll move on to the next error, @undefined local variable or method `login_path'@.

h3. Convenience Routes

Just because we're following the REST convention doesn't mean we can't also create our own named routes.  The view snippet we wrote is attempting to link to @login_path@ and @logout_path@, but our application doesn't yet know about those routes.

Open @/config/routes.rb@ and add two custom routes:

<pre class="brush:ruby">
  match "/login" => redirect("/auth/twitter"), :as => :login
  match "/logout" => "sessions#destroy", :as => :logout  
</pre>

The first line creates a path named @login@ which just redirects to the static address @/auth/twitter@ which will be intercepted by the OmniAuth middleware.  The second line creates a @logout@ path which will call the destroy action of our @SessionsController@.

With those in place, refresh your browser and it should load without error.

h3. Implementing Logout

Our login works great, but we can't logout!  When you click the logout link it's attempting to call the @destroy@ action of @SessionsController@.  Let's implement that.

* Open @SessionsController@
* Add a @destroy@ method
* In the method, erase the session by setting @session[:user_id] = nil@
* Redirect them to the @root_path@ with the notice @"Goodbye!"@
* Define a @root_path@ in your router like this: @root :to => "products#index"@

Now try logging out and you'll probably end up looking at the Rails "Welcome Aboard" page.  Why isn't your @root_path@ taking affect?

If you have a file in @/public@ that matches the requested URL, that will get served without ever triggering your router.  Since Rails generated a @/public/index.html@ file, that's getting served instead of our @root_path@ route.  Delete the @index.html@ file from @public@, and refresh your browser.

*NOTE*: At this point I observed some strange errors from Twitter.  Stopping and restarting my server, which clears the cached data, got it going again.

h3. Connecting Users to Orders

We've done the hard work of creating @User@ objects and logging them into the system.  Now we need to tie orders to users.

h4. Connecting the Order to a User

Open the @Order@ model and add a new @belongs_to@ line:

<pre class="brush:ruby">
  belongs_to :user, :foreign_key => :customer_id
</pre>

Note the extra @foreign_key@ parameter.  In the database that's the name of the column, though our associated model is named @User@.  This extra piece of information tells Rails how to connect them.  That means we also need to modify the @attr_accessible@ line like this:

<pre class="brush:ruby">
  attr_accessible :user, :status
</pre>

h4. Connecting the User to Orders

Then in the @User@ model, just add @has_many :orders@

h3. User/Order Workflow

Now we need to figure out when in the lifecycle we can connect a @User@ and an @Order@

# When an order is created, connect them to the current user if one is logged in
# When they login, connect them to the current order

h4. Displaying the User on the Order

Let's output the associated @User@ on the order's @show@ page.  There's already a TH for "Customer", just add this into the TD:

<pre class="brush:ruby">
  <td><%= @order.user.name if @order.user %></td>
</pre>

h4. When an Order is Created

Our orders are created in the @load_order@ method in @ApplicationController@.  Let's modify it to build off the current user if one is logged in:

<pre class="brush:ruby">
  def load_order
    begin
      @order = Order.find(session[:order_id])
    rescue ActiveRecord::RecordNotFound
      if current_user
        @order = current_user.orders.create(:status => "unsubmitted")
      else
        @order = Order.create(:status => "unsubmitted")
      end
      session[:order_id] = @order.id
    end
  end
</pre>

h4. When an Order Exists *before* They Login

Open up the @SessionsController@.  The @create@ action is what logs them in.  Once the @User@ is known we can look for an existing order and, if there is one, connect it to the @User@:

<pre class="brush:ruby">
  def create
    @user = User.find_or_create_by_auth(request.env["omniauth.auth"])
    session[:user_id] = @user.id
    load_order
    @order.update_attributes(:user_id => @user.id)
    redirect_to products_path, :notice => "Logged in as #{@user.name}"
  end
</pre>

h4. Clear the Order on Logout

As long as we're in the @SessionsController@, let's clear the order from the session when they logout like this:

<pre class="brush:ruby">
  def destroy
    session[:user_id] = nil
    session[:order_id] = nil
    redirect_to root_path
  end  
</pre>

h4. Test It!

Now you should be all set.  Try creating orders when you're not logged in, then login and the order is preserved.  Login first, then create an order and it's connected to your account.

h4. Bonus Points

It would be awesome if, when a user logs in, it would retrieve their last unsubmitted order.  Here's one way to pull it off.

In the @load_order@ method, just change the lookup to @find_or_create_by@ like this:

<pre class="brush:ruby">
  @order = current_user.orders.find_or_create_by_status("unsubmitted")
</pre>

This will work if they are logged out then login before creating an order.  If they've already created an order, then login, though, it won't find the old one.  What would you have the system do in this case? Maybe merge the old saved order and the new one?  Give it a shot!

h1. WORKING

h2. Iteration 7 - Checkout

We've got a decent shopping experience going -- except you can't actually place the order.  As with our other iterations, we'll start with a simple solution and leave the improvements for later.

h4. Creating Customers in the Database

To place an order we need a customer.  When we created the @order@ model we specified that it @belongs_to@ a @customer@.  That means that each @order@ has a field named @customer_id@ where we store the ID of the associated @customer@.

What does a customer include?  What kinds of information do we need to keep track of?  Here are the basics:

* First Name
* Last Name
* Phone Number
* Billing Address
* Shipping Address

Names and the Phone Number can just be stored in the database as strings, but what is an address?  A US address is made up of:

* Street Number & Street Name ("Line 1")
* Apartment / Suite ("Line 2")
* City
* State
* Zipcode

We could break the address into it's own database table then associate that with the customer, but that's more complex than we need at this stage of development.  Instead, let's create a @customer@ object that has all of these fields:

* first_name: string
* last_name: string
* phone_number: string
* billing_line1: string
* billing_line2: string
* billing_city: string
* billing_state: string
* billing_zip: string
* shipping_line1: string
* shipping_line2: string
* shipping_city: string
* shipping_state: string
* shipping_zip: string

Generate a scaffold that includes all of these fields and run the migration to update your database:

<pre class="brush:ruby">
script/generate scaffold Customer first_name:string last_name:string phone_number:string billing_line1:string billing_line2:string billing_city:string billing_state:string billing_zip:string shipping_line1:string shipping_line2:string shipping_city:string shipping_state:string shipping_zip:string
rake db:migrate
</pre>

h4. Validating the Customer Model

Open the @/app/models/customer.rb@ file and let's think about validations.  What do we want to validate about a customer?

* Every field except the line2's must be present<br/>Use one or more @validates_presence_of@ lines with a comma-separated list of the fields you want checked
* Phone number should be 10 digits<br/>Use @validates_length_of@ so it is 10 exactly
* Each zip should be 5 digits<br/>Use @validates_length_of@ so it is 5 exactly.  Also, add a @validates_numericality_of@ to make sure it's all numbers.
* Each state should be 2 letters<br/>Use @validates_length_of@ so it is 2 exactly.

Look at the validations API page here for tips and examples: "http://api.rubyonrails.org/classes/ActiveRecord/Validations/ClassMethods.html":http://api.rubyonrails.org/classes/ActiveRecord/Validations/ClassMethods.html 

We could do more to validate this data like making sure that the @state@ is a valid state, not just any two letters and that the zip is similarly valid.  For now, though, this is enough of a sanity check.  If I were really developing this project, though, I might put a few comments in with the address validations to remind me later -- that'd look like this:

<pre class="brush:ruby">
# Consider adding check against real state abbreviation list
# Consider adding check against valid US zipcodes
</pre>

h4. Adding Customer Fields to our Order

Go back to your @/app/views/orders/show.html.erb@ view template.  We're going to cheat on the RESTful conventions a little to fit our desired workflow.

At the bottom of your table, add this row:

<pre class="brush:ruby">
  <tr>
    <th>Customer Information</th>
    <% if @order.customer.nil? %>
      <td>
        Signup
      </td>
    <% else %>
      <td>
        <b>Billing Address</b><br/>
        <%= @order.customer.billing_line1 %><br/>
        <%= @order.customer.billing_line2 %><br/>
        <%= @order.customer.billing_city %>, <%= @order.customer.billing_state %> <%= @order.customer.billing_zip %>
      </td>
      <td>
        <!-- Shipping Information -->
      </td>
    <% end %>
  </tr>  
</pre>

Fill in the "Shipping Information" following the model of the "Billing Information".  We'll test that once the customer exists, but right now the @@order@ has no @customer@.  Save the view and load an order in your browser.  You should just see the word "Signup" in the "Customer Information" row.

In later versions of the store we'll want to have customer logins, tie multiple orders to a single customer, and so forth.  But for now we are going to just create a new customer for each order.  We'll use a new feature of Rails to make this easier for us.  Flip over to the @order.rb@ model file and, under your validations, add this code:

<pre class="brush:ruby">
  accepts_nested_attributes_for :customer
</pre>

This tells Rails that we want to be able to create and modify the @customer@ through the @order@.  It'll make more sense in a second.  Move back to your order's @show@ view template.  Replace the word "Signup" with this link:

<pre class="brush:ruby">
  <%= link_to "Create a New Customer", edit_order_path(@order) %>
</pre>

Refresh it in your web browser and click the link.

h4. Modifying the Edit Page

We're going to hijack the order's edit page to handle our customer creation.  Is this breaking the REST model? Yep!  Rules were meant to be broken!

Open the @/app/views/orders/edit.html.erb@ view template.  Delete everything from line 6 to line 13, thus removing the fields for @customer_id@ and @status@.  We don't want the shopper changing those.

Open the @/app/views/customers/new.html.erb@ view template.  Copy everything from line 6 to line 57, all the fields for a customer.

Go back over to the order's @edit@ template.  See where it says @|f|@?  That's the name we're giving to the @order@ form.  The fields we're copying over from the customer template also use the name @f@, and we can't have them overlap.  Since there are only a few references to @f@ in the current order form, lets just rename it to @order_form@.  You can do this manually, but RubyMine can help you do it more quickly:

* Highlight the @f@ inside of @|f|@
* Right click on it
* Select @Refactor@ then @Rename@
* Enter @order_form@ as the new name
* Leave the checkboxes unchecked and click @Refactor@

RubyMine then changes all instances of @f@ to @order_form@.  Now we won't have any name conflicts.  Underneath the @error_messages@ line, add this code:

<pre class="brush:ruby">
  <% order_form.fields_for :customer do |f| %>
  
  <% end %>
</pre>

That tells Rails that inside these tags we're going to create a form for the order's @customer@ and we'll refer to the form as @f@.  I used @f@ for convenience, so you can now go between those tags and paste all the fields you copied over from the customer's @new@ template.  If you like, try using the Refactor command to rename all the @f@ occurrences to @customer_form@.

There's one last step to embedding the customer fields inside the @order@.  We need to open up @/app/controllers/orders_controller.rb@ and go to the @edit@ method. Change that method from this:

<pre class="brush:ruby">
  def edit
    @order = Order.find(params[:id])
  end
</pre>

to this:

<pre class="brush:ruby">
  def edit
    @order = Order.find(params[:id])
    if @order.customer.nil?
      @order.customer = Customer.new  
    end
  end
</pre>

All we're doing here is checking if the @order@ already has a @customer@.  If it doesn't, then @order.customer@ will be @nil@, so this code will create a blank new customer for the form to edit.

Save then flip over to your browser and check your work.  Is it showing all the Customer fields?  The page is super ugly -- I'll leave you to do any rearranging to make it look reasonable.  If you'd like to specify more option for your text fields (like their size,etc) check out the Rails API page here: "http://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#M001607":http://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#M001607

h4. Small Touches

We didn't print out the customer's name anywhere on the order's @show@ template.  Add that in somewhere reasonable.

Now that our customer is created there isn't any link to edit the information.  Add in an "(edit)" link modeled after the "Create a New Customer" link.

h4. Place the Order!

We'll create a button that, when clicked:

* Changes the order's status to "submitted"
* Removes the user's ability to modify the order

To achieve this, we'll need to add a custom action to our routing.  Open the routes file (@/app/config/routes.rb@) and change the @map.resources@ line so it looks like this:

<pre class="brush:ruby">
  map.resources :orders, :member => {:submit => :put}
</pre>

This tells Rails that we're adding a custom action to @orders@.  The action will work on just one @order@ which is referred to as a @member@ (or if our action worked on many @orders@, we'd use @collection@).  And requests for this action will come in as a @put@ (as opposed to a @get@).

Go to your order's @show@ template and add this at the bottom:

<pre class="brush:ruby">
  <%= button_to "Submit this Order", submit_order_path(@order) %>
</pre>

This creates a button labeled "Submit this Order" which calls our custom action (@submit@) and specifies the request method as @put@.  Since we declared the custom action in our routes file Rails is able to figure out how to turn @submit_order_path@ into an actual URL.

Try refreshing your browser and clicking the "Submit this Order" button.  You should get an error about an "Unknown Action" -- we told Rails how to find the @submit@ action, we made a link to that action, but we haven't actually created it yet.

Open @/app/controllers/orders_controller.rb@ and just below the @class@ line add this method:

<pre class="brush:ruby">
def submit
  @order = Order.find(params[:id])
  @order.submit_order
  redirect_to(@order)
end
</pre>

Pretty simple -- just find the @order@ by looking at @params[:id]@, call the order's @submit_order@ method, then redirect back to the order's @show@ method.  Then we need to create the @submit_order@ method inside @/app/models/order.rb@:

<pre class="brush:ruby">
def submit_order
  self.status = "submitted"
  self.save
end
</pre>

Why bother with all these methods?  By passing the "work" on to the @order@ model we create a single place where things are actually changed.  In the future, if we want to change the submission code to @"order_submitted"@ for instance, we only have to change it in one place.  Or maybe we want to fire off an email when an order is submitted?  We'd just add those instructions here and not have to change anything else in the workflow.

Go back to your web browser and try out your button.  You should see the order status line flip to "submitted"

h4. Lockouts

All that work to change "unsubmitted" to "submitted".  Now we want to lock out the quantity changing and such once the order is submitted.  Create this method inside the @order@ model file:

<pre class="brush:ruby">
def editable?
  if self.status == "unsubmitted"
    return true
  else
    return false
  end
end
</pre>

Now we can call the @editable?@ method from our view to find out if the order should still be editable.  Here's an example of how to only show the submit button when the order is editable:

<pre class="brush:ruby">
<% if @order.editable? %>
  <%= button_to "Submit this Order", submit_order_path(@order), :method => :put %>
<% end %>
</pre>

Try using that technique to modify the links to change order quantity.  If it's editable, they should be able to change the quantity.  If it's not editable, it should display the quantity without the link.  Also, if you made an edit link for the customer, hide that when the order is not editable. 

Iteration 7 is complete!

h2. Next Steps

There are many ways we can go from this point, here are some ideas:

* Set the a user as admin in console
* Create /logout and /login custom routes
* Add admin checks to views so only they can change product information
* Associate orders with logins
* Create a way to view past orders
* Create an admin view of all order with order status
* Auto-fill order addresses based on customer's previous orders